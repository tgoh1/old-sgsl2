var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

import { CSS, rafFrames, transitionEnd, nativeTimeout } from '../util/dom';
import { assign, isDefined } from '../util/util';
/**
 * @private
 **/
export var Animation = function () {
    function Animation(ele) {
        var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        _classCallCheck(this, Animation);

        this._wChg = false;
        this._rv = false;
        this._lastUpd = 0;
        this.isPlaying = false;
        this.hasTween = false;
        this.hasCompleted = false;
        this._reset();
        this.element(ele);
        this._opts = assign({
            renderDelay: 24
        }, opts);
    }

    _createClass(Animation, [{
        key: '_reset',
        value: function _reset() {
            this._el = [];
            this._c = [];
            this._fx = {};
            this._bfSty = {};
            this._bfAdd = [];
            this._bfRmv = [];
            this._afSty = {};
            this._afAdd = [];
            this._afRmv = [];
            this._pFns = [];
            this._fFns = [];
            this._fOnceFns = [];
            this._easing = this._dur = null;
        }
    }, {
        key: 'element',
        value: function element(ele) {
            var i;
            if (ele) {
                if (Array.isArray(ele)) {
                    for (i = 0; i < ele.length; i++) {
                        this._addEle(ele[i]);
                    }
                } else if (typeof ele === 'string') {
                    ele = document.querySelectorAll(ele);
                    for (i = 0; i < ele.length; i++) {
                        this._addEle(ele[i]);
                    }
                } else {
                    this._addEle(ele);
                }
            }
            return this;
        }
    }, {
        key: '_addEle',
        value: function _addEle(ele) {
            if (ele.nativeElement) {
                ele = ele.nativeElement;
            }
            if (ele.nodeType === 1) {
                this._el.push(ele);
                // does this element suport will-change property?
                this._wChg = typeof ele.style.willChange !== 'undefined';
            }
        }
    }, {
        key: 'parent',
        value: function parent(parentAnimation) {
            this._parent = parentAnimation;
            return this;
        }
    }, {
        key: 'add',
        value: function add(childAnimation) {
            childAnimation.parent(this);
            this._c.push(childAnimation);
            return this;
        }
    }, {
        key: 'getDuration',
        value: function getDuration() {
            return this._dur !== null ? this._dur : this._parent && this._parent.getDuration() || 0;
        }
    }, {
        key: 'duration',
        value: function duration(milliseconds) {
            this._dur = milliseconds;
            return this;
        }
    }, {
        key: 'getEasing',
        value: function getEasing() {
            return this._easing !== null ? this._easing : this._parent && this._parent.getEasing() || null;
        }
    }, {
        key: 'easing',
        value: function easing(name) {
            this._easing = name;
            return this;
        }
    }, {
        key: 'from',
        value: function from(prop, val) {
            this._addProp('from', prop, val);
            return this;
        }
    }, {
        key: 'to',
        value: function to(prop, val, clearProperyAfterTransition) {
            var fx = this._addProp('to', prop, val);
            if (clearProperyAfterTransition) {
                // if this effect is a transform then clear the transform effect
                // otherwise just clear the actual property
                this.after.clearStyles([fx.trans ? CSS.transform : prop]);
            }
            return this;
        }
    }, {
        key: 'fromTo',
        value: function fromTo(prop, fromVal, toVal, clearProperyAfterTransition) {
            return this.from(prop, fromVal).to(prop, toVal, clearProperyAfterTransition);
        }
    }, {
        key: '_addProp',
        value: function _addProp(state, prop, val) {
            var fxProp = this._fx[prop];
            if (!fxProp) {
                // first time we've see this EffectProperty
                fxProp = this._fx[prop] = {
                    trans: typeof TRANSFORMS[prop] !== 'undefined',
                    wc: ''
                };
                // add the will-change property for transforms or opacity
                if (fxProp.trans) {
                    fxProp.wc = CSS.transform;
                } else if (prop === 'opacity') {
                    fxProp.wc = prop;
                }
            }
            // add from/to EffectState to the EffectProperty
            var fxState = fxProp[state] = {
                val: val,
                num: null,
                unit: ''
            };
            if (typeof val === 'string' && val.indexOf(' ') < 0) {
                var r = val.match(CSS_VALUE_REGEX);
                var num = parseFloat(r[1]);
                if (!isNaN(num)) {
                    fxState.num = num;
                }
                fxState.unit = r[0] !== r[2] ? r[2] : '';
            } else if (typeof val === 'number') {
                fxState.num = val;
            }
            return fxProp;
        }
    }, {
        key: 'fadeIn',
        value: function fadeIn() {
            return this.fromTo('opacity', 0.001, 1, true);
        }
    }, {
        key: 'fadeOut',
        value: function fadeOut() {
            return this.fromTo('opacity', 0.999, 0);
        }
    }, {
        key: 'play',
        value: function play() {
            var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

            var self = this;
            var i;
            var duration = isDefined(opts.duration) ? opts.duration : self._dur;
            console.debug('Animation, play, duration', duration, 'easing', self._easing);
            // always default that an animation does not tween
            // a tween requires that an Animation class has an element
            // and that it has at least one FROM/TO effect
            // and that the FROM/TO effect can tween numeric values
            self.hasTween = false;
            self.hasCompleted = false;
            // fire off all the onPlays
            for (i = 0; i < self._pFns.length; i++) {
                self._pFns[i]();
            }
            self.isPlaying = true;
            // this is the top level animation and is in full control
            // of when the async play() should actually kick off
            // if there is no duration then it'll set the TO property immediately
            // if there is a duration, then it'll stage all animations at the
            // FROM property and transition duration, wait a few frames, then
            // kick off the animation by setting the TO property for each animation
            // stage all of the before css classes and inline styles
            // will recursively stage all child elements
            self._before();
            // ensure all past transition end events have been cleared
            self._clearAsync();
            if (duration > 30) {
                // this animation has a duration, so it should animate
                // place all the elements with their FROM properties
                // set the FROM properties
                self._progress(0);
                // add the will-change or translateZ properties when applicable
                self._willChg(true);
                // set the async TRANSITION END event
                // and run onFinishes when the transition ends
                self._asyncEnd(duration, true);
                // begin each animation when everything is rendered in their place
                // and the transition duration/easing is ready to go
                rafFrames(self._opts.renderDelay / 16, function () {
                    // there's been a moment and the elements are in place
                    // now set the TRANSITION duration/easing
                    self._setTrans(duration, false);
                    // wait a few moments again to wait for the transition
                    // info to take hold in the DOM
                    rafFrames(2, function () {
                        // browser had some time to render everything in place
                        // and the transition duration/easing is set
                        // now set the TO properties
                        // which will trigger the transition to begin
                        self._progress(1);
                    });
                });
            } else {
                // this animation does not have a duration, so it should not animate
                // just go straight to the TO properties and call it done
                self._progress(1);
                // since there was no animation, immediately run the after
                self._after();
                // since there was no animation, it's done
                // fire off all the onFinishes
                self._didFinish(true);
            }
        }
    }, {
        key: 'stop',
        value: function stop() {
            var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

            var self = this;
            var duration = isDefined(opts.duration) ? opts.duration : 0;
            var stepValue = isDefined(opts.stepValue) ? opts.stepValue : 1;
            // ensure all past transition end events have been cleared
            this._clearAsync();
            // set the TO properties
            self._progress(stepValue);
            if (duration > 30) {
                // this animation has a duration, so it should animate
                // place all the elements with their TO properties
                // now set the TRANSITION duration
                self._setTrans(duration, true);
                // set the async TRANSITION END event
                // and run onFinishes when the transition ends
                self._asyncEnd(duration, false);
            } else {
                // this animation does not have a duration, so it should not animate
                // just go straight to the TO properties and call it done
                self._after();
                // since there was no animation, it's done
                // fire off all the onFinishes
                self._didFinish(false);
            }
        }
    }, {
        key: '_asyncEnd',
        value: function _asyncEnd(duration, shouldComplete) {
            var self = this;
            function onTransitionEnd(ev) {
                console.debug('Animation onTransitionEnd', ev.target.nodeName, ev.propertyName);
                // ensure transition end events and timeouts have been cleared
                self._clearAsync();
                // set the after styles
                self._after();
                // remove will change properties
                self._willChg(false);
                // transition finished
                self._didFinish(shouldComplete);
            }
            function onTransitionFallback() {
                console.debug('Animation onTransitionFallback');
                // oh noz! the transition end event didn't fire in time!
                // instead the fallback timer when first
                // clear the other async end events from firing
                self._tmr = 0;
                self._clearAsync();
                // too late to have a smooth animation, just finish it
                self._setTrans(0, true);
                // ensure the ending progress step gets rendered
                self._progress(1);
                // set the after styles
                self._after();
                // remove will change properties
                self._willChg(false);
                // transition finished
                self._didFinish(shouldComplete);
            }
            // set the TRANSITION END event on one of the transition elements
            self._unregTrans = transitionEnd(self._transEl(), onTransitionEnd);
            // set a fallback timeout if the transition end event never fires, or is too slow
            // transition end fallback: (animation duration + XXms)
            self._tmr = nativeTimeout(onTransitionFallback, duration + 400);
        }
    }, {
        key: '_clearAsync',
        value: function _clearAsync() {
            this._unregTrans && this._unregTrans();
            if (this._tmr) {
                clearTimeout(this._tmr);
                this._tmr = 0;
            }
        }
    }, {
        key: '_progress',
        value: function _progress(stepValue) {
            // bread 'n butter
            var i;
            var prop;
            var fx;
            var val;
            var transforms;
            var tweenEffect;
            for (i = 0; i < this._c.length; i++) {
                this._c[i]._progress(stepValue);
            }
            if (this._el.length) {
                // flip the number if we're going in reverse
                if (this._rv) {
                    stepValue = stepValue * -1 + 1;
                }
                transforms = [];
                for (prop in this._fx) {
                    fx = this._fx[prop];
                    if (fx.from && fx.to) {
                        tweenEffect = fx.from.num !== fx.to.num;
                        if (tweenEffect) {
                            this.hasTween = true;
                        }
                        if (stepValue === 0) {
                            // FROM
                            val = fx.from.val;
                        } else if (stepValue === 1) {
                            // TO
                            val = fx.to.val;
                        } else if (tweenEffect) {
                            // EVERYTHING IN BETWEEN
                            val = (fx.to.num - fx.from.num) * stepValue + fx.from.num + fx.to.unit;
                        } else {
                            val = null;
                        }
                        if (val !== null) {
                            if (fx.trans) {
                                transforms.push(prop + '(' + val + ')');
                            } else {
                                for (i = 0; i < this._el.length; i++) {
                                    this._el[i].style[prop] = val;
                                }
                            }
                        }
                    }
                }
                // place all transforms on the same property
                if (transforms.length) {
                    if (!this._wChg) {
                        // if the element doesn't support will-change
                        // then auto add translateZ for transform properties
                        transforms.push('translateZ(0px)');
                    }
                    for (i = 0; i < this._el.length; i++) {
                        this._el[i].style[CSS.transform] = transforms.join(' ');
                    }
                }
            }
        }
    }, {
        key: '_setTrans',
        value: function _setTrans(duration, forcedLinearEasing) {
            var i;
            var easing;
            // set the TRANSITION properties inline on the element
            for (i = 0; i < this._c.length; i++) {
                this._c[i]._setTrans(duration, forcedLinearEasing);
            }
            if (Object.keys(this._fx).length) {
                for (i = 0; i < this._el.length; i++) {
                    // all parent/child animations should have the same duration
                    this._el[i].style[CSS.transitionDuration] = duration + 'ms';
                    // each animation can have a different easing
                    easing = forcedLinearEasing ? 'linear' : this.getEasing();
                    if (easing) {
                        this._el[i].style[CSS.transitionTimingFn] = easing;
                    }
                }
            }
        }
    }, {
        key: '_willChg',
        value: function _willChg(addWillChange) {
            var i;
            var wc;
            var prop;
            for (i = 0; i < this._c.length; i++) {
                this._c[i]._willChg(addWillChange);
            }
            if (this._wChg) {
                wc = [];
                if (addWillChange) {
                    for (prop in this._fx) {
                        if (this._fx[prop].wc !== '') {
                            wc.push(this._fx[prop].wc);
                        }
                    }
                }
                for (i = 0; i < this._el.length; i++) {
                    this._el[i].style['willChange'] = wc.join(',');
                }
            }
        }
    }, {
        key: '_before',
        value: function _before() {
            // before the RENDER_DELAY
            // before the animations have started
            var i;
            var j;
            var prop;
            var ele;
            // stage all of the child animations
            for (i = 0; i < this._c.length; i++) {
                this._c[i]._before();
            }
            if (!this._rv) {
                for (i = 0; i < this._el.length; i++) {
                    ele = this._el[i];
                    // css classes to add before the animation
                    for (j = 0; j < this._bfAdd.length; j++) {
                        ele.classList.add(this._bfAdd[j]);
                    }
                    // css classes to remove before the animation
                    for (j = 0; j < this._bfRmv.length; j++) {
                        ele.classList.remove(this._bfRmv[j]);
                    }
                    // inline styles to add before the animation
                    for (prop in this._bfSty) {
                        ele.style[prop] = this._bfSty[prop];
                    }
                }
            }
        }
    }, {
        key: '_after',
        value: function _after() {
            // after the animations have finished
            var i;
            var j;
            var prop;
            var ele;
            for (i = 0; i < this._c.length; i++) {
                this._c[i]._after();
            }
            for (i = 0; i < this._el.length; i++) {
                ele = this._el[i];
                // remove the transition duration/easing
                ele.style[CSS.transitionDuration] = '';
                ele.style[CSS.transitionTimingFn] = '';
                if (this._rv) {
                    // finished in reverse direction
                    // css classes that were added before the animation should be removed
                    for (j = 0; j < this._bfAdd.length; j++) {
                        ele.classList.remove(this._bfAdd[j]);
                    }
                    // css classes that were removed before the animation should be added
                    for (j = 0; j < this._bfRmv.length; j++) {
                        ele.classList.add(this._bfRmv[j]);
                    }
                    // inline styles that were added before the animation should be removed
                    for (prop in this._bfSty) {
                        ele.style[prop] = '';
                    }
                } else {
                    // finished in forward direction
                    // css classes to add after the animation
                    for (j = 0; j < this._afAdd.length; j++) {
                        ele.classList.add(this._afAdd[j]);
                    }
                    // css classes to remove after the animation
                    for (j = 0; j < this._afRmv.length; j++) {
                        ele.classList.remove(this._afRmv[j]);
                    }
                    // inline styles to add after the animation
                    for (prop in this._afSty) {
                        ele.style[prop] = this._afSty[prop];
                    }
                }
            }
        }
    }, {
        key: 'progressStart',
        value: function progressStart() {
            for (var i = 0; i < this._c.length; i++) {
                this._c[i].progressStart();
            }
            this._before();
            // force no duration, linear easing
            this._setTrans(0, true);
        }
    }, {
        key: 'progressStep',
        value: function progressStep(stepValue) {
            var now = Date.now();
            // only update if the last update was more than 16ms ago
            if (now - 16 > this._lastUpd) {
                this._lastUpd = now;
                stepValue = Math.min(1, Math.max(0, stepValue));
                for (var i = 0; i < this._c.length; i++) {
                    this._c[i].progressStep(stepValue);
                }
                if (this._rv) {
                    // if the animation is going in reverse then
                    // flip the step value: 0 becomes 1, 1 becomes 0
                    stepValue = stepValue * -1 + 1;
                }
                this._progress(stepValue);
            }
        }
    }, {
        key: 'progressEnd',
        value: function progressEnd(shouldComplete, currentStepValue) {
            console.debug('Animation, progressEnd, shouldComplete', shouldComplete, 'currentStepValue', currentStepValue);
            for (var i = 0; i < this._c.length; i++) {
                this._c[i].progressEnd(shouldComplete, currentStepValue);
            }
            // set all the animations to their final position
            this._progress(shouldComplete ? 1 : 0);
            // if it's already at the final position, or close, then it's done
            // otherwise we need to add a transition end event listener
            if (currentStepValue < 0.05 || currentStepValue > 0.95) {
                // the progress was already left off at the point that is finished
                // for example, the left menu was dragged all the way open already
                this._after();
                this._willChg(false);
                this._didFinish(shouldComplete);
            } else {
                // the stepValue was left off at a point when it needs to finish transition still
                // for example, the left menu was opened 75% and needs to finish opening
                this._asyncEnd(64, shouldComplete);
                // force quick duration, linear easing
                this._setTrans(64, true);
            }
        }
    }, {
        key: 'onPlay',
        value: function onPlay(callback) {
            this._pFns.push(callback);
            return this;
        }
    }, {
        key: 'onFinish',
        value: function onFinish(callback) {
            var onceTimeCallback = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
            var clearOnFinishCallacks = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

            if (clearOnFinishCallacks) {
                this._fFns = [];
                this._fOnceFns = [];
            }
            if (onceTimeCallback) {
                this._fOnceFns.push(callback);
            } else {
                this._fFns.push(callback);
            }
            return this;
        }
    }, {
        key: '_didFinish',
        value: function _didFinish(hasCompleted) {
            this.isPlaying = false;
            this.hasCompleted = hasCompleted;
            var i;
            for (i = 0; i < this._fFns.length; i++) {
                this._fFns[i](this);
            }
            for (i = 0; i < this._fOnceFns.length; i++) {
                this._fOnceFns[i](this);
            }
            this._fOnceFns = [];
        }
    }, {
        key: 'reverse',
        value: function reverse() {
            var shouldReverse = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

            for (var i = 0; i < this._c.length; i++) {
                this._c[i].reverse(shouldReverse);
            }
            this._rv = shouldReverse;
            return this;
        }
    }, {
        key: 'destroy',
        value: function destroy(removeElement) {
            var i;
            var ele;
            for (i = 0; i < this._c.length; i++) {
                this._c[i].destroy(removeElement);
            }
            if (removeElement) {
                for (i = 0; i < this._el.length; i++) {
                    ele = this._el[i];
                    ele.parentNode && ele.parentNode.removeChild(ele);
                }
            }
            this._clearAsync();
            this._reset();
        }
    }, {
        key: '_transEl',
        value: function _transEl() {
            // get the lowest level element that has an Animation
            var i;
            var targetEl;
            for (i = 0; i < this._c.length; i++) {
                targetEl = this._c[i]._transEl();
                if (targetEl) {
                    return targetEl;
                }
            }
            return this.hasTween && this._el.length ? this._el[0] : null;
        }
        /*
         STATIC CLASSES
         */

    }, {
        key: 'before',
        get: function get() {
            var _this = this;

            return {
                addClass: function addClass(className) {
                    _this._bfAdd.push(className);
                    return _this;
                },
                removeClass: function removeClass(className) {
                    _this._bfRmv.push(className);
                    return _this;
                },
                setStyles: function setStyles(styles) {
                    _this._bfSty = styles;
                    return _this;
                },
                clearStyles: function clearStyles(propertyNames) {
                    for (var i = 0; i < propertyNames.length; i++) {
                        _this._bfSty[propertyNames[i]] = '';
                    }
                    return _this;
                }
            };
        }
    }, {
        key: 'after',
        get: function get() {
            var _this2 = this;

            return {
                addClass: function addClass(className) {
                    _this2._afAdd.push(className);
                    return _this2;
                },
                removeClass: function removeClass(className) {
                    _this2._afRmv.push(className);
                    return _this2;
                },
                setStyles: function setStyles(styles) {
                    _this2._afSty = styles;
                    return _this2;
                },
                clearStyles: function clearStyles(propertyNames) {
                    for (var i = 0; i < propertyNames.length; i++) {
                        _this2._afSty[propertyNames[i]] = '';
                    }
                    return _this2;
                }
            };
        }
    }], [{
        key: 'create',
        value: function create(name) {
            var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

            var AnimationClass = AnimationRegistry[name];
            if (!AnimationClass) {
                // couldn't find an animation by the given name
                // fallback to just the base Animation class
                AnimationClass = Animation;
            }
            return new AnimationClass(null, opts);
        }
    }, {
        key: 'register',
        value: function register(name, AnimationClass) {
            AnimationRegistry[name] = AnimationClass;
        }
    }]);

    return Animation;
}();
var TRANSFORMS = {
    'translateX': 1, 'translateY': 1, 'translateZ': 1,
    'scale': 1, 'scaleX': 1, 'scaleY': 1, 'scaleZ': 1,
    'rotate': 1, 'rotateX': 1, 'rotateY': 1, 'rotateZ': 1,
    'skewX': 1, 'skewY': 1, 'perspective': 1
};
var CSS_VALUE_REGEX = /(^-?\d*\.?\d*)(.*)/;
var AnimationRegistry = {};