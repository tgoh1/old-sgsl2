var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = this && this.__metadata || function (k, v) {
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = this && this.__param || function (paramIndex, decorator) {
    return function (target, key) {
        decorator(target, key, paramIndex);
    };
};
import { Component, Directive, ElementRef, Optional, forwardRef, Inject, ContentChildren, ChangeDetectionStrategy, ViewEncapsulation } from '@angular/core';
import { Button } from '../button/button';
import { Config } from '../../config/config';
import { Ion } from '../ion';
import { Navbar } from '../navbar/navbar';
import { ViewController } from '../nav/view-controller';
/**
 * @private
 */
export var ToolbarBase = function (_Ion) {
    _inherits(ToolbarBase, _Ion);

    function ToolbarBase(elementRef) {
        _classCallCheck(this, ToolbarBase);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ToolbarBase).call(this, elementRef));

        _this.itemRefs = [];
        _this.titleRef = null;
        return _this;
    }
    /**
     * @private
     */


    _createClass(ToolbarBase, [{
        key: "setTitleCmp",
        value: function setTitleCmp(titleCmp) {
            this.titleCmp = titleCmp;
        }
        /**
         * @private
         * Returns the toolbar title text if it exists or an empty string
         */

    }, {
        key: "getTitleText",
        value: function getTitleText() {
            return this.titleCmp && this.titleCmp.getTitleText() || '';
        }
        /**
         * @private
         */

    }, {
        key: "getTitleRef",
        value: function getTitleRef() {
            return this.titleCmp && this.titleCmp.elementRef;
        }
        /**
         * @private
         * A toolbar items include the left and right side `ion-buttons`,
         * and every `menu-toggle`. It does not include the `ion-title`.
         * @returns {TODO} Array of this toolbar's item ElementRefs.
         */

    }, {
        key: "getItemRefs",
        value: function getItemRefs() {
            return this.itemRefs;
        }
        /**
         * @private
         */

    }, {
        key: "addItemRef",
        value: function addItemRef(itemElementRef) {
            this.itemRefs.push(itemElementRef);
        }
    }]);

    return ToolbarBase;
}(Ion);
/**
 * @name Toolbar
 * @description
 * A Toolbar is a generic bar that is positioned above or below content.
 * Unlike a [Navbar](../../nav/Navbar), a toolbar can be used as a subheader.
 * Toolbars are positioned automatically at the `top`, but they can be
 * positioned at the bottom by setting `position="bottom"` on the component.
 *
 *
 * ### Buttons in a Toolbar
 * Buttons placed in a toolbar should be placed inside of the `<ion-buttons>`
 * element. An exception to this is a [menuToggle](../../menu/MenuToggle) button.
 * It should not be placed inside of the `<ion-buttons>` element. Both the
 * `<ion-buttons>` element and the `menuToggle` can be positioned inside of the
 * toolbar using different properties. The below chart has a description of each
 * property.
 *
 * | Property    | Description                                                                                                           |
 * |-------------|-----------------------------------------------------------------------------------------------------------------------|
 * | `start`     | Positions element to the left of the content in `ios` mode, and directly to the right in `md` and `wp` mode.    |
 * | `end`       | Positions element to the right of the content in `ios` mode, and to the far right in `md` and `wp` mode.        |
 * | `left`      | Positions element to the left of all other elements.                                                            |
 * | `right`     | Positions element to the right of all other elements.                                                           |
 *
 * See [usage](#usage) below for some examples.
 *
 *
 * @usage
 * ```html
 * <ion-toolbar>
 *   <ion-buttons start>
 *     <button>
 *       <ion-icon name="contact"></ion-icon>
 *     </button>
 *     <button>
 *       <ion-icon name="search"></ion-icon>
 *     </button>
 *   </ion-buttons>
 *   <ion-title>My Toolbar Title</ion-title>
 * </ion-toolbar>
 *
 * <ion-toolbar>
 *   <ion-title>I'm a subheader</ion-title>
 * </ion-toolbar>
 *
 * <ion-content></ion-content>
 *
 * <ion-toolbar position="bottom">
 *   <ion-title>I'm a subfooter</ion-title>
 *   <ion-buttons right>
 *     <button>
 *       <ion-icon name="menu"></ion-icon>
 *     </button>
 *   </ion-buttons>
 * </ion-toolbar>
 *
 * <ion-toolbar position="bottom">
 *   <ion-title>I'm a footer</ion-title>
 *   <ion-buttons end>
 *     <button>
 *       <ion-icon name="more"></ion-icon>
 *     </button>
 *     <button>
 *       <ion-icon name="options"></ion-icon>
 *     </button>
 *   </ion-buttons>
 * </ion-toolbar>
 *  ```
 *
 * @property {any} [position] - set position of the toolbar, `top` or `bottom`.
 * Default `top`.
 * @demo /docs/v2/demos/toolbar/
 * @see {@link ../../navbar/Navbar/ Navbar API Docs}
 */
export var Toolbar = function (_ToolbarBase) {
    _inherits(Toolbar, _ToolbarBase);

    function Toolbar(viewCtrl, elementRef, config) {
        _classCallCheck(this, Toolbar);

        var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(Toolbar).call(this, elementRef));

        _this2._sbPadding = config.getBoolean('statusbarPadding', false);
        viewCtrl && viewCtrl.setToolbarRef(elementRef);
        return _this2;
    }

    return Toolbar;
}(ToolbarBase);
Toolbar = __decorate([Component({
    selector: 'ion-toolbar',
    template: '<div class="toolbar-background"></div>' + '<ng-content select="[menuToggle],ion-buttons[left]"></ng-content>' + '<ng-content select="ion-buttons[start]"></ng-content>' + '<ng-content select="ion-buttons[end],ion-buttons[right]"></ng-content>' + '<div class="toolbar-content">' + '<ng-content></ng-content>' + '</div>',
    host: {
        'class': 'toolbar',
        '[class.statusbar-padding]': '_sbPadding'
    },
    changeDetection: ChangeDetectionStrategy.OnPush
}), __param(0, Optional()), __metadata('design:paramtypes', [typeof (_a = typeof ViewController !== 'undefined' && ViewController) === 'function' && _a || Object, typeof (_b = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _b || Object, typeof (_c = typeof Config !== 'undefined' && Config) === 'function' && _c || Object])], Toolbar);
/**
 * @name Title
 * @description
 * `ion-title` is a component that sets the title of the `Toolbar` or `Navbar`
 *
 * @usage
 *
 * ```html
 * <ion-navbar *navbar>
 *    <ion-title>Tab 1</ion-title>
 * </ion-navbar>
 * ```
 *
 * Or to create a navbar with a toolbar as a subheader:
 *
 * ```html
 * <ion-navbar *navbar>
 *    <ion-title>Tab 1</ion-title>
 * </ion-navbar>
 *
 * <ion-toolbar>
 *   <ion-title>Subheader</ion-title>
 * </ion-toolbar>
 * ```
 *
 * @demo /docs/v2/demos/title/
 */
export var ToolbarTitle = function (_Ion2) {
    _inherits(ToolbarTitle, _Ion2);

    function ToolbarTitle(elementRef, toolbar, navbar) {
        _classCallCheck(this, ToolbarTitle);

        var _this3 = _possibleConstructorReturn(this, Object.getPrototypeOf(ToolbarTitle).call(this, elementRef));

        toolbar && toolbar.setTitleCmp(_this3);
        navbar && navbar.setTitleCmp(_this3);
        return _this3;
    }
    /**
     * @private
     */


    _createClass(ToolbarTitle, [{
        key: "getTitleText",
        value: function getTitleText() {
            return this.getNativeElement().textContent;
        }
    }]);

    return ToolbarTitle;
}(Ion);
ToolbarTitle = __decorate([Component({
    selector: 'ion-title',
    template: '<div class="toolbar-title">' + '<ng-content></ng-content>' + '</div>',
    changeDetection: ChangeDetectionStrategy.OnPush,
    encapsulation: ViewEncapsulation.None
}), __param(1, Optional()), __param(2, Optional()), __param(2, Inject(forwardRef(function () {
    return Navbar;
}))), __metadata('design:paramtypes', [typeof (_d = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _d || Object, Toolbar, typeof (_e = typeof Navbar !== 'undefined' && Navbar) === 'function' && _e || Object])], ToolbarTitle);
/**
 * @private
 */
export var ToolbarItem = function () {
    function ToolbarItem(elementRef, toolbar, navbar) {
        _classCallCheck(this, ToolbarItem);

        toolbar && toolbar.addItemRef(elementRef);
        navbar && navbar.addItemRef(elementRef);
        this.inToolbar = !!(toolbar || navbar);
    }

    _createClass(ToolbarItem, [{
        key: "_buttons",
        set: function set(buttons) {
            if (this.inToolbar) {
                Button.setRoles(buttons, 'bar-button');
            }
        }
    }]);

    return ToolbarItem;
}();
__decorate([ContentChildren(Button), __metadata('design:type', Object), __metadata('design:paramtypes', [Object])], ToolbarItem.prototype, "_buttons", null);
ToolbarItem = __decorate([Directive({
    selector: 'ion-buttons,[menuToggle],ion-nav-items'
}), __param(1, Optional()), __param(2, Optional()), __param(2, Inject(forwardRef(function () {
    return Navbar;
}))), __metadata('design:paramtypes', [typeof (_f = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _f || Object, Toolbar, typeof (_g = typeof Navbar !== 'undefined' && Navbar) === 'function' && _g || Object])], ToolbarItem);
var _a, _b, _c, _d, _e, _f, _g;